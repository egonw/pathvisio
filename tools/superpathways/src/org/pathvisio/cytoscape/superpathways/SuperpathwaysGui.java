// PathVisio,
// a tool for data visualization and analysis using Biological Pathways
// Copyright 2006-2011 BiGCaT Bioinformatics
//
// Licensed under the Apache License, Version 2.0 (the "License"); 
// you may not use this file except in compliance with the License. 
// You may obtain a copy of the License at 
// 
// http://www.apache.org/licenses/LICENSE-2.0 
//  
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, 
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
// See the License for the specific language governing permissions and 
// limitations under the License.
//

package org.pathvisio.cytoscape.superpathways;

import java.awt.Color;
import java.awt.Cursor;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListModel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.table.TableColumn;

import org.bridgedb.Xref;
import org.bridgedb.bio.Organism;
import org.pathvisio.core.debug.Logger;
import org.pathvisio.core.model.ConverterException;
import org.pathvisio.core.model.ObjectType;
import org.pathvisio.core.model.Pathway;
import org.pathvisio.core.model.PathwayElement;
import org.pathvisio.cytoscape.GpmlHandler;
import org.pathvisio.cytoscape.superpathways.SuperpathwaysClient.FindPathwaysByTextParameters;
import org.pathvisio.cytoscape.superpathways.SuperpathwaysClient.GetPathwayParameters;
import org.pathvisio.desktop.util.ListWithPropertiesTableModel;
import org.pathvisio.desktop.util.RowWithProperties;
import org.pathvisio.wikipathways.webservice.WSPathway;
import org.pathvisio.wikipathways.webservice.WSSearchResult;
import org.wikipathways.client.WikiPathwaysClient;

import cytoscape.CyNetwork;
import cytoscape.Cytoscape;
import cytoscape.data.webservice.CyWebServiceEvent;
import cytoscape.data.webservice.CyWebServiceException;
import cytoscape.data.webservice.WebServiceClientManager;
import cytoscape.data.webservice.CyWebServiceEvent.WSEventType;
import cytoscape.ding.CyGraphAllLOD;
import cytoscape.task.Task;
import cytoscape.task.TaskMonitor;
import cytoscape.task.ui.JTaskConfig;
import cytoscape.task.util.TaskManager;
import cytoscape.view.CyNetworkView;
import cytoscape.visual.CalculatorCatalog;
import cytoscape.visual.GlobalAppearanceCalculator;
import cytoscape.visual.VisualMappingManager;
import cytoscape.visual.VisualStyle;
import ding.view.DGraphView;

//public class SuperpathwaysGui extends JFrame implements ActionListener{ 
public class SuperpathwaysGui extends JPanel {

	// private static String ACTION_SEARCH = "Search";

	private static String ORGANISM_ALL = "All organisms";

	final SuperpathwaysClient mClient;

	ResultRow mSelectedInHelpPanel;

	List<String> mClickedPathwayNameID = new ArrayList<String>();

	List<String> mSelectedPathwayNameID = new ArrayList<String>();

	// this mSelectedPathwaysID is used for pass the reference of Pws to the
	// method in CommonNodeView class
	// use the identifier directly, not the name/identifier combination.
	List<String> mSelectedPathwaysID = new ArrayList<String>();

	// String[] mSelectedPathwaysID = new String[20];

	String mSelectedPwInHelpPanel = "not defined";

	private Map<String, WSSearchResult[]> mNodeIdToPwsSharingNode = new HashMap<String, WSSearchResult[]>();

	private List<String> mCandidatePw;

	int mNoGeneNode;

	Pathway mAnchorPw;

	CommonNodeView cnViewObject;

	PathwaysMerge pMerge;

	static int superpathwaysVisualStyleCounter;

	// List<String> selectedPwsNameId;

	public SuperpathwaysGui(SuperpathwaysClient c) {
		mClient = c;

		initComponents();

		cnViewObject = null;

		superpathwaysVisualStyleCounter = 1;

	}

	// the following code is generated in Netbean IDE
	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed" desc="Generated Code">
	private void initComponents() {

		jScrollPane2 = new javax.swing.JScrollPane();

		// superpathwayPanel = new javax.swing.JTabbedPane();
		searchPane = new javax.swing.JPanel();
		stepLabel1 = new javax.swing.JLabel();
		searchText = new javax.swing.JTextField();
		organismCombo = new javax.swing.JComboBox();
		searchBtn = new javax.swing.JButton();
		// helpButton = new javax.swing.JButton();
		hintLabel1 = new javax.swing.JLabel();
		resultScrolllPane1 = new javax.swing.JScrollPane();
		resultTable = new javax.swing.JTable();
		addBtn = new javax.swing.JButton();
		selectPanel = new javax.swing.JPanel();

		/*
		 * availablePathwaysScrollPane = new javax.swing.JScrollPane();
		 * availablePathwaysList = new javax.swing.JList();
		 * availablePathwaysListModel = new DefaultListModel();
		 * availablePathwaysLabel = new javax.swing.JLabel();
		 */
		removeBtn = new javax.swing.JButton();

		selectedPathwaysLabel = new javax.swing.JLabel();
		selectedPathwaysScrollPane = new javax.swing.JScrollPane();
		selectedPathwaysList = new javax.swing.JList();
		selectedPathwaysListModel = new DefaultListModel();

		findRelatedPwsBtn = new javax.swing.JButton();
		// rightButton = new javax.swing.JButton();
		// leftButton = new javax.swing.JButton();

		ClearBtn = new javax.swing.JButton();
		CommonNodeViewBtn = new javax.swing.JButton();
		MergeBtn = new javax.swing.JButton();

		helpPanel = new javax.swing.JPanel();
		anchorPathwayLabel = new javax.swing.JLabel();
		sharingNodeNoLabel = new javax.swing.JLabel();
		anchorPathwayComboBox = new javax.swing.JComboBox();
		lowerBoundSharingNodeNoComboBox = new javax.swing.JComboBox();
		candidatePathwaysSharingNodesScrollPane = new javax.swing.JScrollPane();

		// candidatePathwaysSharingNodesList = new javax.swing.JList();
		// candidatePathwaysSharingNodesListModel = new DefaultListModel();

		candidatePathwaysSharingNodesTable = new javax.swing.JTable();
		candidatePathwaysSharingNodesTableModel = new javax.swing.table.DefaultTableModel();

		// candidatePathwaysSharingNodesTable.setAutoCreateRowSorter(true);

		explainHelpLabel1 = new javax.swing.JLabel();
		addHelpButton = new javax.swing.JButton();
		lowerBoundLabel = new javax.swing.JLabel();
		upperBoundLabel = new javax.swing.JLabel();
		upperBoundSharingNodeNoComboBox = new javax.swing.JComboBox();
		explainHelpLabel2 = new javax.swing.JLabel();
		backToSearchButton = new javax.swing.JButton();
		searchHelpButton = new javax.swing.JButton();
		lastLabel = new javax.swing.JLabel();

		// setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
		// setTitle("Superpathways");
		// setBackground(new java.awt.Color(255, 255, 255));

		/*
		 * superpathwayPanel.setToolTipText("");
		 * superpathwayPanel.setName("search_select_tab"); // NOI18N
		 * superpathwayPanel.setPreferredSize(new java.awt.Dimension(440, 680));
		 */

		searchPane.setToolTipText("");

		stepLabel1.setBackground(new java.awt.Color(204, 204, 255));
		stepLabel1.setFont(new java.awt.Font("Dialog", 1, 11)); // NOI18N
		stepLabel1.setForeground(new java.awt.Color(102, 0, 0));
		stepLabel1
				.setText("Search and select multiple pathways from WikiPathways");

		searchText.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				searchTextActionPerformed(evt);
			}
		});

		resetOrganisms();

		searchBtn.setText("Search");
		searchBtn.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				searchBtnActionPerformed(evt);
			}
		});

		hintLabel1.setFont(new java.awt.Font("Dialog", 1, 11)); // NOI18N
		hintLabel1
				.setText("You can search by: pathway name, gene/protein name, or any page content");

		resultTable
				.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);

		resultScrolllPane1.setViewportView(resultTable);

		addBtn.setText("Add");
		addBtn
				.setToolTipText("add the selected pathway to the \"Available Pathways\" list");
		addBtn.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				addBtnActionPerformed(evt);
			}
		});

		/*
		 * selectPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(
		 * javax.swing.BorderFactory .createTitledBorder("Please select pathways
		 * to merge"), "",
		 * javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION,
		 * javax.swing.border.TitledBorder.DEFAULT_POSITION, new
		 * java.awt.Font("Tahoma", 0, 11), new java.awt.Color(0, 0, 255))); //
		 * NOI18N
		 */

		selectPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(
				null, "",
				javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION,
				javax.swing.border.TitledBorder.DEFAULT_POSITION,
				new java.awt.Font("Tahoma", 0, 11), new java.awt.Color(0, 0,
						255))); // NOI18N
		/*
		 * availablePathwaysList
		 * .setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		 * availablePathwaysList.setLayoutOrientation(JList.VERTICAL);
		 * availablePathwaysList.setVisibleRowCount(8);
		 * 
		 * availablePathwaysScrollPane.setViewportView(availablePathwaysList);
		 */

		selectedPathwaysList
				.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		selectedPathwaysList.setLayoutOrientation(JList.VERTICAL);
		selectedPathwaysList.setVisibleRowCount(8);
		selectedPathwaysScrollPane.setViewportView(selectedPathwaysList);

		/*
		 * availablePathwaysLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); //
		 * NOI18N availablePathwaysLabel.setForeground(new java.awt.Color(102,
		 * 0, 0)); availablePathwaysLabel.setText("Available Pathways");
		 */
		selectedPathwaysLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
		selectedPathwaysLabel.setForeground(new java.awt.Color(102, 0, 0));
		selectedPathwaysLabel.setText("Selected Pathways");

		removeBtn.setText("Remove");
		removeBtn.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				removeBtnActionPerformed(evt);
			}
		});

		ClearBtn.setText("Clear");
		ClearBtn
				.setToolTipText("clear all the previously selected pathways");
		ClearBtn.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				ClearBtnActionPerformed(evt);
			}
		});
		
		org.jdesktop.layout.GroupLayout selectPanelLayout = new org.jdesktop.layout.GroupLayout(
				selectPanel);
		selectPanel.setLayout(selectPanelLayout);
		selectPanelLayout
				.setHorizontalGroup(selectPanelLayout
						.createParallelGroup(
								org.jdesktop.layout.GroupLayout.LEADING)
						.add(
								selectPanelLayout
										.createSequentialGroup()
										.addContainerGap()
										.add(
												selectPanelLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.LEADING)
														.add(
																org.jdesktop.layout.GroupLayout.TRAILING,
																selectedPathwaysScrollPane,
																org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																371,
																Short.MAX_VALUE)
														.add(
																selectedPathwaysLabel)
														.add(
																org.jdesktop.layout.GroupLayout.TRAILING,
																selectPanelLayout
																		.createSequentialGroup()
																		.add(
																				ClearBtn)
																		.addPreferredGap(
																				org.jdesktop.layout.LayoutStyle.RELATED)
																		.add(
																				removeBtn,
																				org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
																				71,
																				org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
										.addContainerGap()));
		selectPanelLayout
				.setVerticalGroup(selectPanelLayout
						.createParallelGroup(
								org.jdesktop.layout.GroupLayout.LEADING)
						.add(
								selectPanelLayout
										.createSequentialGroup()
										.add(selectedPathwaysLabel)
										.addPreferredGap(
												org.jdesktop.layout.LayoutStyle.RELATED)
										.add(
												selectedPathwaysScrollPane,
												org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
												110,
												org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
										.addPreferredGap(
												org.jdesktop.layout.LayoutStyle.RELATED,
												org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
												Short.MAX_VALUE)
										.add(
												selectPanelLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.BASELINE)
														.add(removeBtn).add(
																ClearBtn))));

		/*
		 * org.jdesktop.layout.GroupLayout selectPanelLayout = new
		 * org.jdesktop.layout.GroupLayout(selectPanel);
		 * selectPanel.setLayout(selectPanelLayout);
		 * selectPanelLayout.setHorizontalGroup(
		 * selectPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
		 * .add(selectPanelLayout.createSequentialGroup() .addContainerGap()
		 * .add(selectPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
		 * .add(org.jdesktop.layout.GroupLayout.TRAILING,
		 * selectedPathwaysScrollPane,
		 * org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 371, Short.MAX_VALUE)
		 * .add(selectedPathwaysLabel)
		 * .add(org.jdesktop.layout.GroupLayout.TRAILING, removeBtn))
		 * .addContainerGap()) ); selectPanelLayout.setVerticalGroup(
		 * selectPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
		 * .add(selectPanelLayout.createSequentialGroup()
		 * .add(selectedPathwaysLabel)
		 * .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
		 * .add(selectedPathwaysScrollPane,
		 * org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 110,
		 * org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
		 * .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED,
		 * org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
		 * .add(removeBtn)) );
		 */

		findRelatedPwsBtn.setText("Find Related Pathways");
		findRelatedPwsBtn
				.setToolTipText("find the related pathways which share nodes with the one you select");
		findRelatedPwsBtn
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						findRelatedPwsBtnActionPerformed(evt);
					}
				});

		

		CommonNodeViewBtn.setText("Common Node View");
		CommonNodeViewBtn
				.setToolTipText("generate a network view showing the number of shared nodes between every two selected pathways");
		CommonNodeViewBtn
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						CommonNodeViewBtnActionPerformed(evt);
					}
				});

		/*
		 * helpButton.setText("Help"); helpButton .setToolTipText("switch to
		 * Search Help tab, where you're provided with help for finding
		 * candidate pathways with shared nodes");
		 * helpButton.addActionListener(new java.awt.event.ActionListener() {
		 * public void actionPerformed(java.awt.event.ActionEvent evt) {
		 * helpButtonActionPerformed(evt); } });
		 */

		MergeBtn.setText("Merge");
		MergeBtn.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				MergeBtnActionPerformed(evt);
			}
		});

		org.jdesktop.layout.GroupLayout searchPaneLayout = new org.jdesktop.layout.GroupLayout(
				searchPane);
		searchPane.setLayout(searchPaneLayout);
		searchPaneLayout
				.setHorizontalGroup(searchPaneLayout
						.createParallelGroup(
								org.jdesktop.layout.GroupLayout.LEADING)
						.add(
								searchPaneLayout
										.createSequentialGroup()
										.addContainerGap()
										.add(
												searchPaneLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.LEADING)
														.add(
																searchPaneLayout
																		.createSequentialGroup()
																		.add(
																				stepLabel1)
																		.addContainerGap(
																				79,
																				Short.MAX_VALUE))
														.add(
																searchPaneLayout
																		.createSequentialGroup()
																		.add(
																				hintLabel1,
																				org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
																				412,
																				org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
																		.addContainerGap(
																				18,
																				Short.MAX_VALUE))
														.add(
																org.jdesktop.layout.GroupLayout.TRAILING,
																searchPaneLayout
																		.createSequentialGroup()
																		.add(
																				searchPaneLayout
																						.createParallelGroup(
																								org.jdesktop.layout.GroupLayout.TRAILING)
																						.add(
																								searchPaneLayout
																										.createSequentialGroup()

																										/*.add(
																												ClearBtn)*/
																										.addPreferredGap(
																												org.jdesktop.layout.LayoutStyle.RELATED)
																										.add(
																												CommonNodeViewBtn)
																										.addPreferredGap(
																												org.jdesktop.layout.LayoutStyle.RELATED)
																										.add(
																												MergeBtn)
																										.add(
																												6,
																												6,
																												6))
																						.add(
																								searchPaneLayout
																										.createSequentialGroup()
																										.add(
																												findRelatedPwsBtn)
																										.addPreferredGap(
																												org.jdesktop.layout.LayoutStyle.UNRELATED)
																										.add(
																												addBtn,
																												org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
																												67,
																												org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
																						.add(
																								org.jdesktop.layout.GroupLayout.LEADING,
																								selectPanel,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								Short.MAX_VALUE)
																						.add(
																								org.jdesktop.layout.GroupLayout.LEADING,
																								resultScrolllPane1,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								407,
																								Short.MAX_VALUE)
																						.add(
																								org.jdesktop.layout.GroupLayout.LEADING,
																								searchPaneLayout
																										.createSequentialGroup()
																										.add(
																												searchText,
																												org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																												171,
																												Short.MAX_VALUE)
																										.addPreferredGap(
																												org.jdesktop.layout.LayoutStyle.UNRELATED)
																										.add(
																												organismCombo,
																												0,
																												151,
																												Short.MAX_VALUE)
																										.addPreferredGap(
																												org.jdesktop.layout.LayoutStyle.UNRELATED)
																										.add(
																												searchBtn)))
																		.add(
																				23,
																				23,
																				23)))));

		/*
		 * searchPaneLayout.linkSize(new java.awt.Component[] { ClearBtn,
		 * helpButton }, org.jdesktop.layout.GroupLayout.HORIZONTAL);
		 */

		searchPaneLayout
				.setVerticalGroup(searchPaneLayout
						.createParallelGroup(
								org.jdesktop.layout.GroupLayout.LEADING)
						.add(
								searchPaneLayout
										.createSequentialGroup()
										.add(28, 28, 28)
										.add(stepLabel1)
										.add(18, 18, 18)
										.add(hintLabel1)
										.add(32, 32, 32)
										.add(
												searchPaneLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.BASELINE)
														.add(
																searchText,
																org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																23,
																Short.MAX_VALUE)
														.add(organismCombo)
														.add(searchBtn))
										.add(18, 18, 18)
										.add(
												resultScrolllPane1,
												org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
												176, Short.MAX_VALUE)
										.add(18, 18, 18)
										.add(
												searchPaneLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.BASELINE)
														.add(findRelatedPwsBtn)
														.add(addBtn))
										.addPreferredGap(
												org.jdesktop.layout.LayoutStyle.RELATED)
										.add(
												selectPanel,
												org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
												org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
												Short.MAX_VALUE)
										.add(39, 39, 39)
										.add(
												searchPaneLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.BASELINE)
														.add(MergeBtn)
														.add(CommonNodeViewBtn)
														/*.add(ClearBtn)*/).add(43,
												43, 43)));

		searchPaneLayout.linkSize(new java.awt.Component[] { addBtn,
				findRelatedPwsBtn }, org.jdesktop.layout.GroupLayout.VERTICAL);

		searchPaneLayout.linkSize(new java.awt.Component[] { searchBtn,
				searchText }, org.jdesktop.layout.GroupLayout.VERTICAL);

		/*searchPaneLayout.linkSize(new java.awt.Component[] { ClearBtn,
				CommonNodeViewBtn }, org.jdesktop.layout.GroupLayout.VERTICAL);*/

		// superpathwayPanel.addTab("Search/Select", searchPane);

		anchorPathwayLabel.setForeground(new java.awt.Color(0, 0, 255));
		anchorPathwayLabel.setText("Pathway");

		sharingNodeNoLabel.setForeground(new java.awt.Color(0, 0, 255));
		sharingNodeNoLabel.setText("Sharing");

		// anchorPathwayComboBox.setModel(new
		// DefaultComboBoxModel(mAvailablePathwaysNameIDList.toArray()));

		anchorPathwayComboBoxModel = new DefaultComboBoxModel();
		anchorPathwayComboBoxModel.addElement((Object) new String(
				"choose one pathway"));
		anchorPathwayComboBox.setModel(anchorPathwayComboBoxModel);

		anchorPathwayComboBox
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						anchorPathwayComboBoxActionPerformed(evt);
					}
				});

		lowerBoundSharingNodeNoComboBox
				.setModel(new javax.swing.DefaultComboBoxModel(new String[] {
						"1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }));

		// candidatePathwaysSharingNodesTable.setModel();

		explainHelpLabel1.setFont(new java.awt.Font("Dialog", 1, 11)); // NOI18N
		explainHelpLabel1.setForeground(new java.awt.Color(102, 0, 0));
		explainHelpLabel1
				.setText("Choose a pathway and set the range of sharing nodes number, a list of ");

		addHelpButton.setText("Add");
		addHelpButton
				.setToolTipText("add the selected pathways to the 'Available Pathways' list");
		/*
		 * addHelpButton.addActionListener(new java.awt.event.ActionListener() {
		 * public void actionPerformed(java.awt.event.ActionEvent evt) {
		 * addHelpButtonActionPerformed(evt); } });
		 */

		lowerBoundLabel.setForeground(new java.awt.Color(0, 0, 255));
		lowerBoundLabel.setText("Minimum");

		upperBoundLabel.setForeground(new java.awt.Color(0, 0, 255));
		upperBoundLabel.setText("Maximum");

		upperBoundSharingNodeNoComboBox
				.setModel(new javax.swing.DefaultComboBoxModel(new String[] {
						"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
						"11", "12", "13", "14", "15", "16", "17", "18", "19",
						"20" }));

		explainHelpLabel2.setFont(new java.awt.Font("Dialog", 1, 11)); // NOI18N
		explainHelpLabel2.setForeground(new java.awt.Color(102, 0, 0));
		explainHelpLabel2
				.setText("candidate pathways with sharing nodes would be returned.");

		lastLabel.setForeground(new java.awt.Color(0, 0, 255));
		lastLabel.setText("Nodes");

		backToSearchButton.setText("Back to Search");
		backToSearchButton
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						backtoSearchButtonActionPerformed(evt);
					}
				});

		searchHelpButton.setText("Search");
		searchHelpButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				searchHelpButtonActionPerformed(evt);
			}
		});

		/*
		 * candidatePathwaysSharingNodesList
		 * .setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		 * candidatePathwaysSharingNodesScrollPane
		 * .setViewportView(candidatePathwaysSharingNodesList);
		 */

		candidatePathwaysSharingNodesTableModel.addColumn("Pathway Name");
		candidatePathwaysSharingNodesTableModel.addColumn("ID");
		candidatePathwaysSharingNodesTableModel.addColumn("No. Shared Nodes");

		candidatePathwaysSharingNodesTable
				.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		candidatePathwaysSharingNodesScrollPane
				.setViewportView(candidatePathwaysSharingNodesTable);
		candidatePathwaysSharingNodesTable
				.setModel(candidatePathwaysSharingNodesTableModel);

		TableColumn column = null;
		for (int i = 0; i < 3; i++) {
			column = candidatePathwaysSharingNodesTable.getColumnModel()
					.getColumn(i);
			if (i == 0) {
				column.setPreferredWidth(150); // third column is bigger
			} else if (i == 1) {
				column.setPreferredWidth(40);
			} else {
				column.setPreferredWidth(60);
			}

		}

		org.jdesktop.layout.GroupLayout helpPanelLayout = new org.jdesktop.layout.GroupLayout(
				helpPanel);
		helpPanel.setLayout(helpPanelLayout);
		helpPanelLayout
				.setHorizontalGroup(helpPanelLayout
						.createParallelGroup(
								org.jdesktop.layout.GroupLayout.LEADING)
						.add(
								helpPanelLayout
										.createSequentialGroup()
										.add(
												helpPanelLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.LEADING)
														.add(
																helpPanelLayout
																		.createSequentialGroup()
																		.addContainerGap()
																		.add(
																				explainHelpLabel1))
														.add(
																helpPanelLayout
																		.createSequentialGroup()
																		.addContainerGap()
																		.add(
																				explainHelpLabel2))
														.add(
																helpPanelLayout
																		.createSequentialGroup()
																		.add(
																				19,
																				19,
																				19)
																		.add(
																				helpPanelLayout
																						.createParallelGroup(
																								org.jdesktop.layout.GroupLayout.LEADING)
																						.add(
																								anchorPathwayLabel)
																						.add(
																								sharingNodeNoLabel))
																		.add(
																				6,
																				6,
																				6)
																		.add(
																				helpPanelLayout
																						.createParallelGroup(
																								org.jdesktop.layout.GroupLayout.LEADING,
																								false)
																						.add(
																								helpPanelLayout
																										.createSequentialGroup()
																										.add(
																												lowerBoundLabel)
																										.add(
																												18,
																												18,
																												18)
																										.add(
																												lowerBoundSharingNodeNoComboBox,
																												org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
																												org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																												org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
																										.add(
																												18,
																												18,
																												18)
																										.add(
																												upperBoundLabel)
																										.add(
																												18,
																												18,
																												18)
																										.add(
																												upperBoundSharingNodeNoComboBox,
																												org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
																												org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																												org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
																						.add(
																								helpPanelLayout
																										.createSequentialGroup()
																										.add(
																												23,
																												23,
																												23)
																										.add(
																												anchorPathwayComboBox,
																												0,
																												org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																												Short.MAX_VALUE)))
																		.add(
																				18,
																				18,
																				18)
																		.add(
																				lastLabel)
																		.add(
																				18,
																				18,
																				18)
																		.add(
																				searchHelpButton)))
										.addContainerGap(24, Short.MAX_VALUE))
						.add(
								org.jdesktop.layout.GroupLayout.TRAILING,
								helpPanelLayout
										.createSequentialGroup()
										.addContainerGap(190, Short.MAX_VALUE)
										.add(backToSearchButton)
										.addPreferredGap(
												org.jdesktop.layout.LayoutStyle.RELATED)
										.add(addHelpButton).add(26, 26, 26))
						.add(
								helpPanelLayout
										.createSequentialGroup()
										.addContainerGap()
										.add(
												candidatePathwaysSharingNodesScrollPane,
												org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
												402, Short.MAX_VALUE).add(16,
												16, 16)));

		helpPanelLayout.linkSize(new java.awt.Component[] { addHelpButton,
				backToSearchButton },
				org.jdesktop.layout.GroupLayout.HORIZONTAL);

		helpPanelLayout
				.setVerticalGroup(helpPanelLayout
						.createParallelGroup(
								org.jdesktop.layout.GroupLayout.LEADING)
						.add(
								helpPanelLayout
										.createSequentialGroup()
										.add(33, 33, 33)
										.add(explainHelpLabel1)
										.addPreferredGap(
												org.jdesktop.layout.LayoutStyle.UNRELATED)
										.add(explainHelpLabel2)
										.add(44, 44, 44)
										.add(
												helpPanelLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.BASELINE)
														.add(anchorPathwayLabel)
														.add(
																anchorPathwayComboBox,
																org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
																org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
										.add(23, 23, 23)
										.add(
												helpPanelLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.BASELINE)
														.add(lowerBoundLabel)
														.add(
																lowerBoundSharingNodeNoComboBox,
																org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
																org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
														.add(upperBoundLabel)
														.add(
																upperBoundSharingNodeNoComboBox,
																org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
																org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
														.add(lastLabel)
														.add(searchHelpButton)
														.add(sharingNodeNoLabel))
										.add(53, 53, 53)
										.add(
												candidatePathwaysSharingNodesScrollPane,
												org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
												251, Short.MAX_VALUE)
										.add(29, 29, 29)
										.add(
												helpPanelLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.BASELINE)
														.add(backToSearchButton)
														.add(addHelpButton))
										.addContainerGap(131, Short.MAX_VALUE)));

		helpPanelLayout.linkSize(new java.awt.Component[] { addHelpButton,
				backToSearchButton }, org.jdesktop.layout.GroupLayout.VERTICAL);

		helpPanelLayout.linkSize(new java.awt.Component[] { lastLabel,
				lowerBoundLabel, lowerBoundSharingNodeNoComboBox,
				searchHelpButton, sharingNodeNoLabel, upperBoundLabel,
				upperBoundSharingNodeNoComboBox },
				org.jdesktop.layout.GroupLayout.VERTICAL);

		// remove the Search Help panel
		/*
		 * superpathwayPanel .addTab("Search Help", null, helpPanel, "help is
		 * provided for finding candidate pathways with shared nodes");
		 */
		// jScrollPane2.setViewportView(superpathwayPanel);
		jScrollPane2.setViewportView(searchPane);

		org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(
				this);
		setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(
				org.jdesktop.layout.GroupLayout.LEADING).add(
				layout.createSequentialGroup().add(18, 18, 18).add(
						jScrollPane2,
						org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 447,
						Short.MAX_VALUE).add(20, 20, 20)));
		layout.setVerticalGroup(layout.createParallelGroup(
				org.jdesktop.layout.GroupLayout.LEADING).add(
				layout.createSequentialGroup().add(20, 20, 20).add(
						jScrollPane2,
						org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 701,
						Short.MAX_VALUE).addContainerGap()));

		// pack();
	}// </editor-fold>

	private void searchTextActionPerformed(java.awt.event.ActionEvent evt) {
		searchActionPerformed(evt);
	}

	private void searchBtnActionPerformed(java.awt.event.ActionEvent evt) {
		searchActionPerformed(evt);
	}

	private void addBtnActionPerformed(java.awt.event.ActionEvent evt) {
		// System.out.println(mClickedPathwayNameID.size() + "");
		mClickedPathwayNameID.clear();

		int[] rows = resultTable.getSelectedRows();
		for (int k = 0; k < rows.length; k++) {
			int viewRow = rows[k];
			int modelRow = sorter.modelIndex(viewRow);

			ResultRow t = tableModel.getRow(modelRow);
			String temp = t.getProperty(ResultProperty.NAME) + "("
					+ t.getProperty(ResultProperty.ID) + ")";

			mClickedPathwayNameID.add(temp);

		}
		for (int i = 0; i < mClickedPathwayNameID.size(); i++) {
			System.out.println(mClickedPathwayNameID.get(i));
			if (!selectedPathwaysListModel.contains(mClickedPathwayNameID
					.get(i))) {
				selectedPathwaysListModel.addElement(mClickedPathwayNameID
						.get(i));
				selectedPathwaysList.setModel(selectedPathwaysListModel);
				/*
				 * if (availablePathwaysListModel.getSize() > 0) {
				 * rightButton.setEnabled(true); }
				 */

				mSelectedPathwayNameID.add(mClickedPathwayNameID.get(i));

				// add the pathways IDs to the list mSelectedPathwaysID
				String t = mClickedPathwayNameID.get(i);
				int index1 = t.lastIndexOf("(");
				int index2 = t.lastIndexOf(")");
				String pwID = t.substring(index1 + 1, index2);
				mSelectedPathwaysID.add(pwID);

				/*
				 * anchorPathwayComboBoxModel.addElement(mClickedPathwayNameID
				 * .get(i));
				 * anchorPathwayComboBox.setModel(anchorPathwayComboBoxModel);
				 */
			}
		}

	}

	private void removeBtnActionPerformed(java.awt.event.ActionEvent evt) {
		Object[] temp = selectedPathwaysList.getSelectedValues();
		for (int i = 0; i < temp.length; i++) {
			mSelectedPathwayNameID.remove((String) temp[i]);

			// removed the selected item in the selected pathways list
			selectedPathwaysListModel.removeElement(temp[i]);
			String t = (String) temp[i];
			int index1 = t.lastIndexOf("(");
			int index2 = t.lastIndexOf(")");
			String pwID = t.substring(index1 + 1, index2);
			mSelectedPathwaysID.remove(pwID);
		}
	}

	private void findRelatedPwsBtnActionPerformed(java.awt.event.ActionEvent evt) {
		System.out.println("After clicking 'Find Related Pathways' button!");
		int[] rows = resultTable.getSelectedRows();

		if (rows.length > 1 || rows.length == 0) {
			JOptionPane
					.showMessageDialog(
							this,
							"Please select ONE pathway among the search result",
							"find related pathways...",
							JOptionPane.INFORMATION_MESSAGE);
		} else {
			int viewRow = rows[0];
			int modelRow = sorter.modelIndex(viewRow);

			ResultRow t = tableModel.getRow(modelRow);
			String temp = t.getProperty(ResultProperty.NAME) + "("
					+ t.getProperty(ResultProperty.ID) + ")";

			FindRelatedPwsDialog relatedPwsDialog = new FindRelatedPwsDialog(
					mClient, "Find related pathways...", temp);
			relatedPwsDialog.setVisible(true);

		}

	}

	private void ClearBtnActionPerformed(java.awt.event.ActionEvent evt) {
		// SuperpathwaysPlugin spPlugin = SuperpathwaysPlugin.getInstance();
		// spPlugin.mWindow.setVisible(false);
		// spPlugin.mWindow.dispose();
		searchText.setText("");
		/*
		 * availablePathwaysListModel.clear();
		 * availablePathwaysList.setModel(availablePathwaysListModel);
		 */
		selectedPathwaysListModel.clear();
		selectedPathwaysList.setModel(selectedPathwaysListModel);
		//anchorPathwayComboBox.setModel(new DefaultComboBoxModel());
		mSelectedPathwaysID.clear();
		mSelectedPathwayNameID.clear();

	}

	private void CommonNodeViewBtnActionPerformed(java.awt.event.ActionEvent evt) {

		System.out.println("Display the selected pws' id:");
		for (int k = 0; k < mSelectedPathwaysID.size(); k++) {
			System.out.println(mSelectedPathwaysID.get(k));
		}

		/*
		 * Object[] selectedPwNameId = selectedPathwaysListModel.toArray();
		 * selectedPwsNameId = new ArrayList<String>(); for (int i = 0; i <
		 * selectedPwNameId.length; i++) { selectedPwsNameId.add((String)
		 * selectedPwNameId[i]); }
		 */

		commonNodeViewTask task = new commonNodeViewTask(mClient);
		JTaskConfig config = new JTaskConfig();
		config.displayCancelButton(true);
		// config.setModal(true);
		config.setModal(false);
		TaskManager.executeTask(task, config);
	}

	private void searchHelpButtonActionPerformed(java.awt.event.ActionEvent evt) {

		candidatePathwaysSharingNodesTableModel = new javax.swing.table.DefaultTableModel();
		candidatePathwaysSharingNodesTableModel.addColumn("Pathway Name");
		candidatePathwaysSharingNodesTableModel.addColumn("ID");
		candidatePathwaysSharingNodesTableModel.addColumn("No. Shared Nodes");

		candidatePathwaysSharingNodesTable
				.setModel(candidatePathwaysSharingNodesTableModel);
		setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

		// String anchorPwNameAndId =
		// anchorPathwayComboBox.getSelectedItem().toString();
		int lowerBound = Integer.parseInt(lowerBoundSharingNodeNoComboBox
				.getSelectedItem().toString());
		int upperBound = Integer.parseInt(upperBoundSharingNodeNoComboBox
				.getSelectedItem().toString());

		// mCandidatePwList = findCandidatePwBySharingNodes(lowerBound,
		// upperBound);

		searchSharingNodePwsTask task = new searchSharingNodePwsTask(
				lowerBound, upperBound);

		JTaskConfig config = new JTaskConfig();
		config.displayCancelButton(true);
		// config.displayCloseButton(true);
		// config.displayStatus(true);
		config.setModal(true);
		TaskManager.executeTask(task, config);

		// mCandidatePw is a list of string with elements in format "Pathway
		// Name (pw id), sharing node number: a int"

		// System.out.println("We reach here 3!");
		// System.out.println(mCandidatePw.size()+"");
		Iterator<String> it = mCandidatePw.iterator();
		while (it.hasNext()) {
			String temp = it.next();
			// candidatePathwaysSharingNodesListModel.addElement(temp);

			// System.out.println(temp);
			// parse the string into three parts: pathway name, id, and No.
			// Sharing Nodes
			int index1 = temp.indexOf(",");
			String temp1 = temp.substring(0, index1);

			int index2 = temp1.lastIndexOf("(");
			int index3 = temp1.lastIndexOf(")");
			String pwName = temp1.substring(0, index2);
			// System.out.println(pwName);
			String pwId = temp1.substring(index2 + 1, index3);
			// System.out.println(pwId);

			// String temp2 = temp.substring(index1+1);
			int index4 = temp.indexOf(":");
			String NoSharingNode = temp.substring(index4 + 2);
			// System.out.println(NoSharingNode);

			Object[] row = new Object[3];
			row[0] = (Object) pwName;
			row[1] = (Object) pwId;
			row[2] = (Object) NoSharingNode;

			candidatePathwaysSharingNodesTableModel.addRow(row);

		}

		sorter = new TableSorter(candidatePathwaysSharingNodesTableModel);
		candidatePathwaysSharingNodesTable.setModel(sorter);
		sorter.setTableHeader(candidatePathwaysSharingNodesTable
				.getTableHeader());

		// candidatePathwaysSharingNodesList.setModel(candidatePathwaysSharingNodesListModel);
		setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
	}

	private void backtoSearchButtonActionPerformed(
			java.awt.event.ActionEvent evt) {
		// System.out.println("Clicking the back to search button!");
		// superpathwayPanel.setSelectedIndex(0);
	}

	private void anchorPathwayComboBoxActionPerformed(
			java.awt.event.ActionEvent evt) {
		String anchorPwNameId = anchorPathwayComboBox.getSelectedItem()
				.toString();

		if (anchorPwNameId.equalsIgnoreCase("choose one pathway")) {

		} else {
			int index1 = anchorPwNameId.lastIndexOf("(");
			int index2 = anchorPwNameId.lastIndexOf(")");
			String anchorPwID = anchorPwNameId.substring(index1 + 1, index2);

			// Create a client to the WikiPathways web service
			WikiPathwaysClient client = mClient.getStub();

			// Download these two pathways from WikiPathways by passing their id
			WSPathway anchorPathway = new WSPathway();

			try {
				anchorPathway = client.getPathway(anchorPwID);

			} catch (RemoteException e) {
				Logger.log.error(
						"Unable to get the pathway due to the RemoteException",
						e);
			} catch (ConverterException e) {
				Logger.log
						.error(
								"Unable to get the pathway due to the ConverterException",
								e);
			}
			// Create two corresponding pathway objects
			mAnchorPw = new Pathway();

			try {
				mAnchorPw = WikiPathwaysClient.toPathway(anchorPathway);
			} catch (ConverterException e) {
				Logger.log.error(
						"Unable to get the pathway due to the RemoteException",
						e);
			}

			mNoGeneNode = 0;
			for (PathwayElement pwElm : mAnchorPw.getDataObjects()) {
				if (pwElm.getObjectType() == ObjectType.DATANODE) {
					mNoGeneNode = mNoGeneNode + 1;

				}
			}

			String[] temp = new String[mNoGeneNode];
			for (int i = 1; i <= mNoGeneNode; i++) {
				temp[i - 1] = String.valueOf(i);
			}

			upperBoundSharingNodeNoComboBox
					.setModel(new javax.swing.DefaultComboBoxModel(temp));

		}
	}

	private void MergeBtnActionPerformed(java.awt.event.ActionEvent evt) {
		// SimpleCaseMergeTest test=new SimpleCaseMergeTest();

		WikiPathwaysClient client = mClient.getStub();
		SuperpathwaysPlugin spPlugin = SuperpathwaysPlugin.getInstance();
		MergeTask task = new MergeTask(spPlugin, client);

		// Configure JTask Dialog Pop-Up Box
		final JTaskConfig jTaskConfig = new JTaskConfig();

		jTaskConfig.displayCloseButton(true);
		jTaskConfig.displayCancelButton(true);
		jTaskConfig.displayStatus(true);
		jTaskConfig.displayTimeElapsed(true);

		jTaskConfig.setAutoDispose(false);
		// jTaskConfig.setModal(true);
		jTaskConfig.setModal(false);

		// Execute Task in New Thread; pop open JTask Dialog Box.
		TaskManager.executeTask(task, jTaskConfig);
		if (task.isCancelled())
			return;

	}

	// the code above is generated in Netbean IDE

	protected void resetOrganisms() {
		List<String> organisms = new ArrayList<String>();
		organisms.add(ORGANISM_ALL);
		try {
			organisms.addAll(Arrays.asList(mClient.listOrganisms()));
		} catch (Exception e) {
			Logger.log.error("Unable to get organisms for WikiPathways client",
					e);
		}

		organismCombo.setModel(new DefaultComboBoxModel(organisms.toArray()));
	}

	public void searchActionPerformed(java.awt.event.ActionEvent evt) {
		// String action = e.getActionCommand();
		// if(ACTION_SEARCH.equals(action)) {
		FindPathwaysByTextParameters request = new FindPathwaysByTextParameters();
		request.query = searchText.getText();
		String org = organismCombo.getSelectedItem().toString();
		if (!ORGANISM_ALL.equals(org)) {
			request.species = Organism.fromLatinName(org);
		}
		try {
			WebServiceClientManager
					.getCyWebServiceEventSupport()
					.fireCyWebServiceEvent(
							new CyWebServiceEvent<FindPathwaysByTextParameters>(
									mClient.getClientID(),
									WSEventType.SEARCH_DATABASE, request));

		} catch (CyWebServiceException ex) {
			switch (ex.getErrorCode()) {
			case NO_RESULT:
				JOptionPane.showMessageDialog(this,
						"The search didn't return any results", "No results",
						JOptionPane.INFORMATION_MESSAGE);
				break;
			case OPERATION_NOT_SUPPORTED:
			case REMOTE_EXEC_FAILED:
				JOptionPane.showMessageDialog(this, "Error: "
						+ ex.getErrorCode() + ". See log for details", "Error",
						JOptionPane.ERROR_MESSAGE);
				break;
			}
			ex.printStackTrace();
		}
		// }
	}

	private void openNetwork(ResultRow mSelected) {
		try {
			GetPathwayParameters request = new GetPathwayParameters();
			WSSearchResult result = mSelected.getResult();
			request.id = result.getId();
			request.revision = Integer.parseInt(result.getRevision());
			WebServiceClientManager.getCyWebServiceEventSupport()
					.fireCyWebServiceEvent(
							new CyWebServiceEvent(mClient.getClientID(),
									WSEventType.IMPORT_NETWORK, request));
		} catch (CyWebServiceException ex) {
			JOptionPane.showMessageDialog(SuperpathwaysGui.this, "Error: "
					+ ex.getErrorCode() + ". See error log for details",
					"Error", JOptionPane.ERROR_MESSAGE);
		}
	}

	public void setResults(WSSearchResult[] results) {

		tableModel = new ListWithPropertiesTableModel<ResultProperty, ResultRow>();
		if (results != null) {
			tableModel.setColumns(new ResultProperty[] { ResultProperty.NAME,
					ResultProperty.ID, ResultProperty.ORGANISM, });

			resultTable.setModel(tableModel);
			for (WSSearchResult r : results) {
				tableModel.addRow(new ResultRow(r));
			}
		}

		sorter = new TableSorter(tableModel);
		resultTable.setModel(sorter);
		sorter.setTableHeader(resultTable.getTableHeader());

		// resultTable.setModel(tableModel);
		System.out.println("Superpathways!");

	}

	// private javax.swing.DefaultListModel availablePathwaysListModel;
	// javax.swing.DefaultListModel availablePathwaysListModel;

	// private javax.swing.DefaultListModel selectedPathwaysListModel;
	javax.swing.DefaultListModel selectedPathwaysListModel;

	private javax.swing.DefaultComboBoxModel anchorPathwayComboBoxModel;

	// private javax.swing.DefaultListModel
	// candidatePathwaysSharingNodesListModel;

	private javax.swing.table.DefaultTableModel candidatePathwaysSharingNodesTableModel;

	private TableSorter sorter;

	private javax.swing.JButton ClearBtn;

	private javax.swing.JButton CommonNodeViewBtn;

	private javax.swing.JButton addBtn;

	private javax.swing.JButton addHelpButton;

	private javax.swing.JComboBox anchorPathwayComboBox;

	private javax.swing.JLabel anchorPathwayLabel;

	// private javax.swing.JLabel availablePathwaysLabel;

	// private javax.swing.JList availablePathwaysList;
	// javax.swing.JList availablePathwaysList;

	// private javax.swing.JScrollPane availablePathwaysScrollPane;

	private javax.swing.JButton backToSearchButton;

	private javax.swing.JScrollPane candidatePathwaysSharingNodesScrollPane;

	// private javax.swing.JList candidatePathwaysSharingNodesList;

	private javax.swing.JLabel explainHelpLabel1;

	private javax.swing.JLabel explainHelpLabel2;

	private javax.swing.JPanel helpPanel;

	private javax.swing.JLabel hintLabel1;

	// private javax.swing.JButton leftButton;

	private javax.swing.JLabel lowerBoundLabel;

	private javax.swing.JComboBox lowerBoundSharingNodeNoComboBox;

	private javax.swing.JButton findRelatedPwsBtn;

	private javax.swing.JComboBox organismCombo;

	private javax.swing.JScrollPane resultScrolllPane1;

	private javax.swing.JTable resultTable;

	// private javax.swing.JButton rightButton;
	// javax.swing.JButton rightButton;

	private javax.swing.JButton searchBtn;

	private javax.swing.JPanel searchPane;

	private javax.swing.JTextField searchText;

	private javax.swing.JPanel selectPanel;

	private javax.swing.JLabel selectedPathwaysLabel;

	// private javax.swing.JList selectedPathwaysList;
	javax.swing.JList selectedPathwaysList;

	private javax.swing.JScrollPane selectedPathwaysScrollPane;

	private javax.swing.JLabel sharingNodeNoLabel;

	private javax.swing.JLabel stepLabel1;

	private javax.swing.JLabel stepLabel2;

	// private javax.swing.JTabbedPane superpathwayPanel;

	private javax.swing.JLabel upperBoundLabel;

	private javax.swing.JComboBox upperBoundSharingNodeNoComboBox;

	private javax.swing.JButton searchHelpButton;

	// private javax.swing.JButton helpButton;

	private javax.swing.JLabel lastLabel;

	private javax.swing.JTable candidatePathwaysSharingNodesTable;

	private javax.swing.JScrollPane jScrollPane2;

	private javax.swing.JButton MergeBtn;

	private javax.swing.JButton removeBtn;

	// private javax.swing.JList candidatePathwaysSharingNodesList;

	// End of variables declaration
	ListWithPropertiesTableModel<ResultProperty, ResultRow> tableModel;

	class ResultRow implements RowWithProperties<ResultProperty> {
		WSSearchResult result;

		public ResultRow(WSSearchResult result) {
			this.result = result;
		}

		public WSSearchResult getResult() {
			return result;
		}

		public String getProperty(ResultProperty prop) {
			switch (prop) {
			case NAME:
				return result.getName();
			case ORGANISM:
				return result.getSpecies();
			case SCORE:
				return Double.toString(result.getScore());
			case URL:
				return result.getUrl();
				// helen add
			case ID:
				return result.getId();
			}
			return null;
		}
	}

	public class searchSharingNodePwsTask implements Task {

		TaskMonitor monitor;

		int lowerBound;

		int upperBound;

		public searchSharingNodePwsTask(int lb, int ub) {
			lowerBound = lb;
			upperBound = ub;
		}

		/**
		 * Run the Task.
		 */
		public void run() {

			try {
				mCandidatePw = new ArrayList<String>();
				if (lowerBound > upperBound) {
					JOptionPane.showMessageDialog(helpPanel,
							"Please reset the range of sharing nodes number!");
				} else {

					Map<String, Integer> sharingNodeNumberofPws = new HashMap<String, Integer>();
					List<String> geneIDList = new ArrayList<String>();
					int percentComplete = 0;
					int t = 0;

					// Create a client to the WikiPathways web service
					WikiPathwaysClient client = mClient.getStub();

					// the following code is get a map "mNodeIdToPwsSharingNode"
					// with key of GeneID and value of a list of pathways which
					// contain the GeneID
					for (PathwayElement pwElm : mAnchorPw.getDataObjects()) {
						// Only take elements with type DATANODE (genes,
						// proteins, metabolites)
						if (pwElm.getObjectType() == ObjectType.DATANODE) {

							percentComplete = (int) (((double) t / mNoGeneNode) * 98);

							// System.out.println(pwElm.getXref().toString());
							geneIDList.add(pwElm.getXref().toString());

							try {

								WSSearchResult[] PwsSharingNode = client
										.findPathwaysByXref(pwElm.getXref());
								// System.out.println("" +
								// PwsSharingNode.length);
								mNodeIdToPwsSharingNode.put(pwElm.getXref()
										.toString(), PwsSharingNode);

								if (monitor != null) {
									monitor
											.setPercentCompleted(percentComplete);
								}

							} catch (RemoteException e) {
								Logger.log
										.error(
												"Unable to find the candidate pathways due to the RemoteException",
												e);
							}
						}
						t++;

					}

					// the following code is for converting the above map to
					// another map "sharingNodeNumberofPws" with key of
					// the name and id of a pathway, and value of the number of
					// shared node of this pathway and the anchor pathway
					for (int i = 0; i < mNoGeneNode; i++) {
						WSSearchResult[] pwsArray = mNodeIdToPwsSharingNode
								.get(geneIDList.get(i));

						for (int j = 0; j < pwsArray.length; j++) {
							WSSearchResult pw = pwsArray[j];
							ResultRow pwResultRow = new ResultRow(pw);
							String onePwNameAndId = pwResultRow
									.getProperty(ResultProperty.NAME)
									+ "("
									+ pwResultRow
											.getProperty(ResultProperty.ID)
									+ ")";

							if (sharingNodeNumberofPws
									.containsKey(onePwNameAndId)) {
								Integer oldValue = sharingNodeNumberofPws
										.get(onePwNameAndId);
								Integer newValue = new Integer(oldValue + 1);
								sharingNodeNumberofPws.put(onePwNameAndId,
										newValue);
							} else {
								sharingNodeNumberofPws.put(onePwNameAndId, 1);
							}
						}
					}

					// the following code is for displaying the result in the
					// table of
					// "Search Help" panel
					Set<String> sharingNodePwsSet = sharingNodeNumberofPws
							.keySet();
					Iterator<String> it = sharingNodePwsSet.iterator();
					while (it.hasNext()) {
						String temp = it.next();
						Integer value = sharingNodeNumberofPws.get(temp);
						if (value >= lowerBound && value <= upperBound) {
							mCandidatePw.add(temp + ", sharing node number: "
									+ String.valueOf(value));
						}
					}

				}

				if (monitor != null) {
					monitor.setPercentCompleted(100);
				}
				// System.out.println("We reach here 2!");
			} catch (Exception e) {
				Logger.log.error("Error while searching candidate pathways", e);
				JOptionPane.showMessageDialog(mClient.getGUI(), "Error: "
						+ e.getMessage() + ". See log for details", "Error",
						JOptionPane.ERROR_MESSAGE);
			}

		}

		public void halt() {
		}

		public void setTaskMonitor(TaskMonitor m)
				throws IllegalThreadStateException {
			monitor = m;
		}

		public String getTitle() {
			return new String(
					"Searching candidate pathways with shared nodes...");
		}
	}

	public class commonNodeViewTask implements Task {

		TaskMonitor monitor;

		boolean cancelled;

		// List<String> selectedPwNameId;
		SuperpathwaysClient client;

		public commonNodeViewTask(SuperpathwaysClient b) {
			// selectedPwNameId=a;
			client = b;
			cancelled = false;
		}

		public void run() {
			try {

				cnViewObject = new CommonNodeView(mSelectedPathwaysID,
						mSelectedPathwayNameID, client);
				cnViewObject.drawCommonNodeView();

				// the following code is for printing out the matched node pair
				// by translation
				System.out
						.println("printing out the matched node pair by translation");
				Set<Xref> s = cnViewObject.getNodePairByTranslation().keySet();
				Iterator<Xref> it = s.iterator();
				while (it.hasNext()) {
					Xref x1 = it.next();
					Xref x2 = cnViewObject.getNodePairByTranslation().get(x1);
					System.out
							.println(x1.toString() + "======" + x2.toString());
				}

			} catch (Exception e) {
				Logger.log.error("Error while searching candidate pathways", e);
				JOptionPane.showMessageDialog(mClient.getGUI(), "Error: "
						+ e.getMessage() + ". See log for details", "Error",
						JOptionPane.ERROR_MESSAGE);
			}
		}

		public void halt() {
			cancelled = true;
			cnViewObject.interrupt();
		}

		public void setTaskMonitor(TaskMonitor m)
				throws IllegalThreadStateException {
			monitor = m;
		}

		public String getTitle() {
			return new String("Generating common node view...");
		}

	}

	class MergeTask implements Task {

		TaskMonitor monitor;

		boolean cancelled;

		// PathwaysMerge pMerge;
		SuperpathwaysPlugin spPlugin;

		WikiPathwaysClient client;

		/**
		 * Constructor.<br>
		 * 
		 */
		public MergeTask(SuperpathwaysPlugin sp, WikiPathwaysClient c) {
			cancelled = false;
			spPlugin = sp;
			client = c;
		}

		public boolean isCancelled() {
			return cancelled;
		}

		public void run() {

			// if (cnViewObject==null){
			// here we need to re-run the CommonNodeView to get the correct
			// NodePairByTranslation, and colorPool

			cnViewObject = new CommonNodeView(mSelectedPathwaysID,
					mSelectedPathwayNameID, mClient);

			pMerge = new PathwaysMerge(null, cnViewObject
					.getNodePairByTranslation(), null);
			// here we call the method drawCommonNodeView(), because we want to
			// make the correspondance of the color between the common node view
			// and the merged network

			Map<String, Color> pwNameToColor = null;
			if (!isCancelled()) {
				try {
					pwNameToColor = cnViewObject.drawCommonNodeView();
				} catch (Exception e) {
					Logger.log.error("Unable to draw common node view", e);
				}

				WSPathway wsPathway = new WSPathway();
				Pathway pathway = new Pathway();
				List<CyNetwork> listOfNetworks = new ArrayList<CyNetwork>();

				for (int i = 0; i < selectedPathwaysListModel.getSize(); i++) {

					System.out.println("in for loop: " + i + "");
					String selectedOnePwNameID = (String) selectedPathwaysListModel
							.get(i);
					System.out.println(selectedOnePwNameID);
					int index1 = selectedOnePwNameID.lastIndexOf("(");
					int index2 = selectedOnePwNameID.lastIndexOf(")");
					String pwID = selectedOnePwNameID.substring(index1 + 1,
							index2);
					String pwName = selectedOnePwNameID.substring(0, index1);
					// System.out.println(pwID);
					// System.out.println(pwName);

					try {
						wsPathway = client.getPathway(pwID);
						pathway = WikiPathwaysClient.toPathway(wsPathway);
					} catch (RemoteException e) {
						Logger.log
								.error(
										"Unable to get the pathway due to the RemoteException",
										e);
					} catch (ConverterException e) {
						Logger.log
								.error(
										"Unable to get the pathway due to the ConverterException",
										e);
					}

					CyNetwork net = spPlugin.load(pathway, true);

					// the following code is for coloring the nodes by default
					if(pwNameToColor != null) applyGpmlVisualStyle(mClient.getPlugin().mGpmlHandler,
							pwNameToColor, pwName, true,
							superpathwaysVisualStyleCounter);

					listOfNetworks.add(net);
				}

				// convert the array of type Color to an array of type String
				String[] temp = new String[cnViewObject.getColorPool().size()];
				Object[] colors = cnViewObject.getColorPool().toArray();
				for (int s = 0; s < temp.length; s++) {
					temp[s] = (String) colors[s];
				}
				System.out.println("Problem is here2!");
				pMerge = new PathwaysMerge(listOfNetworks, cnViewObject
						.getNodePairByTranslation(), temp);

				try {
					pMerge.setTaskMonitor(monitor);

					CyNetwork mergedNetwork = pMerge.mergeNetwork(
							"Merged Network", cnViewObject
									.getNodePairByTranslation());
					CyNetworkView view = Cytoscape
							.createNetworkView(mergedNetwork);

					superpathwaysVisualStyle vs = new superpathwaysVisualStyle(
							"Merged Network", pwNameToColor,
							superpathwaysVisualStyleCounter);
					superpathwaysVisualStyleCounter++;

				} catch (Exception e) {
					monitor.setException(e, "Network Merge Failed!");
					e.printStackTrace();
				}

				// the following code is for forcing detail rendering at any
				// level of
				// zoom
				CyNetworkView currView = Cytoscape.getCurrentNetworkView();
				ding.view.DGraphView nv;
				nv = (DGraphView) currView;
				nv.setGraphLOD(new CyGraphAllLOD());
			}

		}

		public void halt() {
			cancelled = true;
			cnViewObject.interrupt();
			pMerge.interrupt();
		}

		public void setTaskMonitor(TaskMonitor taskMonitor)
				throws IllegalThreadStateException {
			this.monitor = taskMonitor;
		}

		public String getTitle() {
			return "Merging pathways";
		}
	}

	public void applyGpmlVisualStyle(GpmlHandler gpmlHandler,
			Map<String, Color> pwNameToColor, String t,
			boolean coloringNodeInGpml, int version) {

		if (coloringNodeInGpml == true) {
			VisualMappingManager vmm = Cytoscape.getVisualMappingManager();
			CalculatorCatalog catalog = vmm.getCalculatorCatalog();
			// the next code line is used for fix the bug (when doing several
			// merges)
			// catalog.removeVisualStyle(gpmlExtendVisualStyle.NAME);

			String styleName = gpmlExtendVisualStyle.NAME + "-"
					+ String.valueOf(version);
			System.out.println("GPML-extention style name: " + styleName);

			VisualStyle gpmlExtensionStyle = catalog.getVisualStyle(styleName);

			if (gpmlExtensionStyle == null) { // Create the GPML visual style
				Logger.log.trace("VisualStyle: creating GPML-extension style");
				System.out.println(pwNameToColor.size() + "");
				gpmlExtensionStyle = new gpmlExtendVisualStyle(gpmlHandler,
						pwNameToColor, t, version);

				// set the background color
				GlobalAppearanceCalculator gCalc = gpmlExtensionStyle
						.getGlobalAppearanceCalculator();
				gCalc.setDefaultBackgroundColor(new Color(200, 200, 255));
				vmm.applyGlobalAppearances();

				catalog.addVisualStyle(gpmlExtensionStyle);
			} else {
				System.out.println("gpml-extension style is not null!");
				Logger.log.trace("VisualStyle: reusing GPML-extension style");
			}
			System.out.println("Problem is here1!");
			cytoscape.view.CyNetworkView networkView = Cytoscape
					.getNetworkView(t);
			networkView.setVisualStyle(gpmlExtensionStyle.getName());

			// actually apply the visual style
			vmm.setVisualStyle(gpmlExtensionStyle);
			networkView.redrawGraph(true, true);
		}
	}
}